#!/usr/bin/env python3
"""
Extract Python code blocks from methodology markdown files.

This script automatically extracts all Python code from the methodology
READMEs and saves them as standalone Python files in the appropriate directories.

Usage:
    python extract_code_from_methodology.py
    python extract_code_from_methodology.py --file ../data_collection/README.md --output data_collection/
"""

import re
import os
import argparse
from pathlib import Path
from typing import List, Tuple

def extract_code_blocks(markdown_content: str) -> List[Tuple[str, str, int]]:
    """
    Extract all Python code blocks from markdown content.
    
    Returns:
        List of tuples: (code_content, context_before, line_number)
    """
    lines = markdown_content.split('\n')
    code_blocks = []
    in_code_block = False
    current_code = []
    code_start_line = 0
    context_before = ""
    
    for i, line in enumerate(lines):
        if line.strip().startswith('```python'):
            in_code_block = True
            code_start_line = i + 1
            # Get context from previous 5 lines
            context_start = max(0, i - 5)
            context_before = '\n'.join(lines[context_start:i])
            current_code = []
        elif line.strip().startswith('```') and in_code_block:
            in_code_block = False
            if current_code:
                code_blocks.append((
                    '\n'.join(current_code),
                    context_before,
                    code_start_line
                ))
        elif in_code_block:
            current_code.append(line)
    
    return code_blocks

def infer_filename(code: str, context: str) -> str:
    """
    Infer appropriate filename from code content and context.
    
    Priority:
    1. Class name (lowercase)
    2. Main function name
    3. File path comment
    4. Context heading
    """
    # Check for file path in comment
    file_comment_match = re.search(r'#\s*(?:tools/)?([a-z_/]+\.py)', context + '\n' + code)
    if file_comment_match:
        return file_comment_match.group(1).split('/')[-1]
    
    # Check for class definition
    class_match = re.search(r'class\s+([A-Z][a-zA-Z0-9]*)', code)
    if class_match:
        class_name = class_match.group(1)
        # Convert CamelCase to snake_case
        filename = re.sub(r'(?<!^)(?=[A-Z])', '_', class_name).lower()
        return f"{filename}.py"
    
    # Check for main function definition
    func_match = re.search(r'def\s+([a-z_][a-z0-9_]*)\s*\(', code)
    if func_match:
        return f"{func_match.group(1)}.py"
    
    # Default to generic name
    return None

def save_code_file(code: str, filepath: Path, overwrite: bool = False):
    """Save code to file with proper formatting."""
    if filepath.exists() and not overwrite:
        print(f"  âš ï¸  Skipping {filepath} (already exists)")
        return False
    
    # Ensure directory exists
    filepath.parent.mkdir(parents=True, exist_ok=True)
    
    # Add file header
    header = f'''"""
Extracted from LLM Training Methodology.
Auto-generated by extract_code_from_methodology.py
"""

'''
    
    with open(filepath, 'w') as f:
        f.write(header)
        f.write(code)
        f.write('\n')
    
    print(f"  âœ… Created {filepath}")
    return True

def process_markdown_file(
    markdown_path: Path,
    output_dir: Path,
    overwrite: bool = False
):
    """Process a single markdown file and extract all code."""
    print(f"\nðŸ“– Processing: {markdown_path.name}")
    
    with open(markdown_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    code_blocks = extract_code_blocks(content)
    print(f"  Found {len(code_blocks)} Python code blocks")
    
    saved_count = 0
    unnamed_count = 0
    
    for i, (code, context, line_num) in enumerate(code_blocks):
        # Skip very short snippets (< 5 lines)
        if len(code.strip().split('\n')) < 5:
            continue
        
        filename = infer_filename(code, context)
        
        if not filename:
            unnamed_count += 1
            filename = f"extracted_{unnamed_count}.py"
        
        output_path = output_dir / filename
        
        if save_code_file(code, output_path, overwrite):
            saved_count += 1
    
    print(f"  ðŸ’¾ Saved {saved_count} files to {output_dir}/")
    return saved_count

def main():
    parser = argparse.ArgumentParser(
        description="Extract Python code from LLM Training methodology"
    )
    parser.add_argument(
        '--file',
        type=Path,
        help="Specific markdown file to process"
    )
    parser.add_argument(
        '--output',
        type=Path,
        help="Output directory"
    )
    parser.add_argument(
        '--overwrite',
        action='store_true',
        help="Overwrite existing files"
    )
    parser.add_argument(
        '--all',
        action='store_true',
        help="Process all methodology files"
    )
    
    args = parser.parse_args()
    
    # Determine base directory (parent of tools/)
    script_dir = Path(__file__).parent
    tools_dir = script_dir.parent
    base_dir = tools_dir.parent
    
    print("=" * 60)
    print("  LLM Training Tools - Code Extractor")
    print("=" * 60)
    
    if args.file and args.output:
        # Process single file
        process_markdown_file(args.file, args.output, args.overwrite)
    
    elif args.all:
        # Process all methodology files
        files_to_process = [
            (base_dir / "data_collection" / "README.md", tools_dir / "data_collection"),
            (base_dir / "evaluation" / "README.md", tools_dir / "evaluation"),
            (base_dir / "DEPLOYMENT.md", tools_dir / "deployment"),
        ]
        
        total_saved = 0
        for markdown_file, output_dir in files_to_process:
            if markdown_file.exists():
                saved = process_markdown_file(markdown_file, output_dir, args.overwrite)
                total_saved += saved
            else:
                print(f"  âš ï¸  File not found: {markdown_file}")
        
        print("\n" + "=" * 60)
        print(f"  âœ… Total files extracted: {total_saved}")
        print("=" * 60)
    
    else:
        parser.print_help()
        print("\nExample usage:")
        print("  # Extract all code from all methodology files:")
        print("  python extract_code_from_methodology.py --all")
        print("\n  # Extract from specific file:")
        print("  python extract_code_from_methodology.py \\")
        print("    --file ../data_collection/README.md \\")
        print("    --output data_collection/")

if __name__ == "__main__":
    main()
