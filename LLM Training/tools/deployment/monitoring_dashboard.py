"""
Extracted from LLM Training Methodology.
Auto-generated by extract_code_from_methodology.py
"""

# tools/monitoring_dashboard.py

from flask import Flask, render_template, jsonify
import json
from datetime import datetime, timedelta

app = Flask(__name__)

@app.route("/dashboard")
def dashboard():
    """Production monitoring dashboard."""
    return render_template("monitor.html")

@app.route("/api/metrics")
def get_metrics():
    """API endpoint for dashboard data."""

    metrics = monitor.get_dashboard_metrics()

    # Add drift status
    metrics["drift_status"] = {
        "concept_drift": check_concept_drift_status(),
        "data_drift": check_data_drift_status()
    }

    # Add recent alerts
    metrics["recent_alerts"] = get_recent_alerts(limit=10)

    return jsonify(metrics)

@app.route("/api/timeseries")
def get_timeseries():
    """Get time-series data for charts."""

    # Load metrics from last 24 hours
    with open("llm_requests.log", "r") as f:
        logs = [json.loads(line) for line in f]

    cutoff_time = time.time() - 86400  # 24 hours ago
    recent_logs = [log for log in logs if log["timestamp"] > cutoff_time]

    # Aggregate by hour
    hourly_metrics = {}

    for log in recent_logs:
        hour = datetime.fromtimestamp(log["timestamp"]).strftime("%Y-%m-%d %H:00")

        if hour not in hourly_metrics:
            hourly_metrics[hour] = {
                "requests": 0,
                "total_latency": 0,
                "errors": 0,
                "thumbs_up": 0,
                "thumbs_down": 0
            }

        hourly_metrics[hour]["requests"] += 1
        hourly_metrics[hour]["total_latency"] += log.get("latency_ms", 0)
        if log.get("error"):
            hourly_metrics[hour]["errors"] += 1
        if log.get("feedback") == 1:
            hourly_metrics[hour]["thumbs_up"] += 1
        elif log.get("feedback") == -1:
            hourly_metrics[hour]["thumbs_down"] += 1

    # Format for chart
    timeseries = {
        "timestamps": sorted(hourly_metrics.keys()),
        "requests_per_hour": [hourly_metrics[h]["requests"] for h in sorted(hourly_metrics.keys())],
        "avg_latency_ms": [hourly_metrics[h]["total_latency"] / hourly_metrics[h]["requests"] if hourly_metrics[h]["requests"] > 0 else 0 for h in sorted(hourly_metrics.keys())],
        "error_rate": [hourly_metrics[h]["errors"] / hourly_metrics[h]["requests"] if hourly_metrics[h]["requests"] > 0 else 0 for h in sorted(hourly_metrics.keys())],
        "satisfaction_rate": [hourly_metrics[h]["thumbs_up"] / (hourly_metrics[h]["thumbs_up"] + hourly_metrics[h]["thumbs_down"]) if (hourly_metrics[h]["thumbs_up"] + hourly_metrics[h]["thumbs_down"]) > 0 else 0 for h in sorted(hourly_metrics.keys())]
    }

    return jsonify(timeseries)

def check_concept_drift_status():
    """Check if concept drift alert exists in last 30 days."""
    # Check drift_alerts.jsonl
    try:
        with open("drift_alerts.jsonl", "r") as f:
            alerts = [json.loads(line) for line in f]

        cutoff = time.time() - (30 * 86400)  # 30 days
        recent_concept_drift = any(
            a for a in alerts
            if a["type"] == "concept_drift" and a["timestamp"] > cutoff
        )

        return "DRIFTED" if recent_concept_drift else "STABLE"
    except FileNotFoundError:
        return "UNKNOWN"

def check_data_drift_status():
    """Check if data drift alert exists in last 7 days."""
    try:
        with open("drift_alerts.jsonl", "r") as f:
            alerts = [json.loads(line) for line in f]

        cutoff = time.time() - (7 * 86400)  # 7 days
        recent_data_drift = any(
            a for a in alerts
            if a["type"] == "data_drift" and a["timestamp"] > cutoff
        )

        return "DRIFTED" if recent_data_drift else "STABLE"
    except FileNotFoundError:
        return "UNKNOWN"

def get_recent_alerts(limit=10):
    """Get most recent alerts."""
    try:
        with open("production_alerts.jsonl", "r") as f:
            alerts = [json.loads(line) for line in f]

        # Sort by timestamp, most recent first
        alerts.sort(key=lambda x: x["timestamp"], reverse=True)

        return alerts[:limit]
    except FileNotFoundError:
        return []

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
